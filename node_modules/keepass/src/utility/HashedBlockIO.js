'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _buffer = require('buffer');

var _errors = require('./errors');

var _errors2 = _interopRequireDefault(_errors);

var _BufferReader = require('./BufferReader');

var _BufferReader2 = _interopRequireDefault(_BufferReader);

var HashedBlockIO = function HashedBlockIO() {
  _classCallCheck(this, HashedBlockIO);
};

var BLOCK_SIZE = 1024 * 1024;

HashedBlockIO.decrypt = function (database) {
  _errors2['default'].buffer(database, 'database');

  var r = new _BufferReader2['default'](database);
  var blocks = [];
  while (true) {
    r.nextUInt32LE(); //index in theory it could be in any order?
    var blockHash = r.nextBuffer(32);
    var blockLength = r.nextUInt32LE();
    if (blockLength === 0) {
      break;
    }
    var blockData = r.nextBuffer(blockLength);

    var calculatedHash = _crypto2['default'].createHash('sha256').update(blockData).digest();

    // Compare calculated with stored hash
    if (!calculatedHash.equals(blockHash)) {
      throw new Error('HBIO hash mismatch. The database seems to be corrupt.');
    } else {
      blocks.push(blockData);
    }
  }

  return _buffer.Buffer.concat(blocks);
};

HashedBlockIO.encrypt = function (database) {
  _errors2['default'].buffer(database, 'database');

  var databaseSize = database.length;
  var parts = [];
  var index = 0;
  for (var offset = 0; offset < databaseSize; index++, offset += BLOCK_SIZE) {
    var blockLength = Math.min(BLOCK_SIZE, databaseSize - offset);
    var blockData = database.slice(offset, offset + blockLength);
    var blockHash = _crypto2['default'].createHash('sha256').update(blockData).digest();

    var blockHeader = new _buffer.Buffer(4 + 32 + 4);
    blockHeader.writeUInt32LE(index, 0);
    blockHash.copy(blockHeader, 4);
    blockHeader.writeUInt32LE(blockLength, 36);

    parts.push(blockHeader);
    parts.push(blockData);
  }

  var endBlock = new _buffer.Buffer(40);
  endBlock.fill(0);
  endBlock.writeUInt32LE(index, 0);

  parts.push(endBlock);
  return _buffer.Buffer.concat(parts);
};

exports['default'] = HashedBlockIO;
module.exports = exports['default'];